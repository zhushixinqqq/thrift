/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "plugin_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace apache { namespace thrift { namespace plugin {

int _kt_baseValues[] = {
  t_base::TYPE_VOID,
  t_base::TYPE_STRING,
  t_base::TYPE_BOOL,
  t_base::TYPE_I8,
  t_base::TYPE_I16,
  t_base::TYPE_I32,
  t_base::TYPE_I64,
  t_base::TYPE_DOUBLE,
  t_base::TYPE_BINARY
};
const char* _kt_baseNames[] = {
  "TYPE_VOID",
  "TYPE_STRING",
  "TYPE_BOOL",
  "TYPE_I8",
  "TYPE_I16",
  "TYPE_I32",
  "TYPE_I64",
  "TYPE_DOUBLE",
  "TYPE_BINARY"
};
const std::map<int, const char*> _t_base_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kt_baseValues, _kt_baseNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kRequirednessValues[] = {
  Requiredness::T_REQUIRED,
  Requiredness::T_OPTIONAL,
  Requiredness::T_OPT_IN_REQ_OUT
};
const char* _kRequirednessNames[] = {
  "T_REQUIRED",
  "T_OPTIONAL",
  "T_OPT_IN_REQ_OUT"
};
const std::map<int, const char*> _Requiredness_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kRequirednessValues, _kRequirednessNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


TypeMetadata::~TypeMetadata() throw() {
}


void TypeMetadata::__set_name(const std::string& val) {
  this->name = val;
}

void TypeMetadata::__set_program_id(const t_program_id val) {
  this->program_id = val;
}

void TypeMetadata::__set_annotations(const std::map<std::string, std::string> & val) {
  this->annotations = val;
__isset.annotations = true;
}

void TypeMetadata::__set_doc(const std::string& val) {
  this->doc = val;
__isset.doc = true;
}

uint32_t TypeMetadata::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_program_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->program_id);
          isset_program_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 99:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->annotations.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _ktype1;
            ::apache::thrift::protocol::TType _vtype2;
            xfer += iprot->readMapBegin(_ktype1, _vtype2, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              std::string _key5;
              xfer += iprot->readString(_key5);
              std::string& _val6 = this->annotations[_key5];
              xfer += iprot->readString(_val6);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.annotations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->doc);
          this->__isset.doc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_program_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TypeMetadata::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TypeMetadata");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("program_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->program_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.annotations) {
    xfer += oprot->writeFieldBegin("annotations", ::apache::thrift::protocol::T_MAP, 99);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->annotations.size()));
      std::map<std::string, std::string> ::const_iterator _iter7;
      for (_iter7 = this->annotations.begin(); _iter7 != this->annotations.end(); ++_iter7)
      {
        xfer += oprot->writeString(_iter7->first);
        xfer += oprot->writeString(_iter7->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.doc) {
    xfer += oprot->writeFieldBegin("doc", ::apache::thrift::protocol::T_STRING, 100);
    xfer += oprot->writeString(this->doc);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TypeMetadata &a, TypeMetadata &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.program_id, b.program_id);
  swap(a.annotations, b.annotations);
  swap(a.doc, b.doc);
  swap(a.__isset, b.__isset);
}

TypeMetadata::TypeMetadata(const TypeMetadata& other8) {
  name = other8.name;
  program_id = other8.program_id;
  annotations = other8.annotations;
  doc = other8.doc;
  __isset = other8.__isset;
}
TypeMetadata& TypeMetadata::operator=(const TypeMetadata& other9) {
  name = other9.name;
  program_id = other9.program_id;
  annotations = other9.annotations;
  doc = other9.doc;
  __isset = other9.__isset;
  return *this;
}
void TypeMetadata::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TypeMetadata(";
  out << "name=" << to_string(name);
  out << ", " << "program_id=" << to_string(program_id);
  out << ", " << "annotations="; (__isset.annotations ? (out << to_string(annotations)) : (out << "<null>"));
  out << ", " << "doc="; (__isset.doc ? (out << to_string(doc)) : (out << "<null>"));
  out << ")";
}


t_base_type::~t_base_type() throw() {
}


void t_base_type::__set_metadata(const TypeMetadata& val) {
  this->metadata = val;
}

void t_base_type::__set_value(const t_base::type val) {
  this->value = val;
}

uint32_t t_base_type::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_metadata = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metadata.read(iprot);
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->value = (t_base::type)ecast10;
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t t_base_type::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("t_base_type");

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->metadata.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(t_base_type &a, t_base_type &b) {
  using ::std::swap;
  swap(a.metadata, b.metadata);
  swap(a.value, b.value);
}

t_base_type::t_base_type(const t_base_type& other11) {
  metadata = other11.metadata;
  value = other11.value;
}
t_base_type& t_base_type::operator=(const t_base_type& other12) {
  metadata = other12.metadata;
  value = other12.value;
  return *this;
}
void t_base_type::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "t_base_type(";
  out << "metadata=" << to_string(metadata);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


t_list::~t_list() throw() {
}


void t_list::__set_metadata(const TypeMetadata& val) {
  this->metadata = val;
}

void t_list::__set_cpp_name(const std::string& val) {
  this->cpp_name = val;
__isset.cpp_name = true;
}

void t_list::__set_elem_type(const t_type_id val) {
  this->elem_type = val;
}

uint32_t t_list::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_metadata = false;
  bool isset_elem_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metadata.read(iprot);
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cpp_name);
          this->__isset.cpp_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->elem_type);
          isset_elem_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_elem_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t t_list::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("t_list");

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->metadata.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.cpp_name) {
    xfer += oprot->writeFieldBegin("cpp_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->cpp_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("elem_type", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->elem_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(t_list &a, t_list &b) {
  using ::std::swap;
  swap(a.metadata, b.metadata);
  swap(a.cpp_name, b.cpp_name);
  swap(a.elem_type, b.elem_type);
  swap(a.__isset, b.__isset);
}

t_list::t_list(const t_list& other13) {
  metadata = other13.metadata;
  cpp_name = other13.cpp_name;
  elem_type = other13.elem_type;
  __isset = other13.__isset;
}
t_list& t_list::operator=(const t_list& other14) {
  metadata = other14.metadata;
  cpp_name = other14.cpp_name;
  elem_type = other14.elem_type;
  __isset = other14.__isset;
  return *this;
}
void t_list::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "t_list(";
  out << "metadata=" << to_string(metadata);
  out << ", " << "cpp_name="; (__isset.cpp_name ? (out << to_string(cpp_name)) : (out << "<null>"));
  out << ", " << "elem_type=" << to_string(elem_type);
  out << ")";
}


t_set::~t_set() throw() {
}


void t_set::__set_metadata(const TypeMetadata& val) {
  this->metadata = val;
}

void t_set::__set_cpp_name(const std::string& val) {
  this->cpp_name = val;
__isset.cpp_name = true;
}

void t_set::__set_elem_type(const t_type_id val) {
  this->elem_type = val;
}

uint32_t t_set::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_metadata = false;
  bool isset_elem_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metadata.read(iprot);
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cpp_name);
          this->__isset.cpp_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->elem_type);
          isset_elem_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_elem_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t t_set::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("t_set");

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->metadata.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.cpp_name) {
    xfer += oprot->writeFieldBegin("cpp_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->cpp_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("elem_type", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->elem_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(t_set &a, t_set &b) {
  using ::std::swap;
  swap(a.metadata, b.metadata);
  swap(a.cpp_name, b.cpp_name);
  swap(a.elem_type, b.elem_type);
  swap(a.__isset, b.__isset);
}

t_set::t_set(const t_set& other15) {
  metadata = other15.metadata;
  cpp_name = other15.cpp_name;
  elem_type = other15.elem_type;
  __isset = other15.__isset;
}
t_set& t_set::operator=(const t_set& other16) {
  metadata = other16.metadata;
  cpp_name = other16.cpp_name;
  elem_type = other16.elem_type;
  __isset = other16.__isset;
  return *this;
}
void t_set::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "t_set(";
  out << "metadata=" << to_string(metadata);
  out << ", " << "cpp_name="; (__isset.cpp_name ? (out << to_string(cpp_name)) : (out << "<null>"));
  out << ", " << "elem_type=" << to_string(elem_type);
  out << ")";
}


t_map::~t_map() throw() {
}


void t_map::__set_metadata(const TypeMetadata& val) {
  this->metadata = val;
}

void t_map::__set_cpp_name(const std::string& val) {
  this->cpp_name = val;
__isset.cpp_name = true;
}

void t_map::__set_key_type(const t_type_id val) {
  this->key_type = val;
}

void t_map::__set_val_type(const t_type_id val) {
  this->val_type = val;
}

uint32_t t_map::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_metadata = false;
  bool isset_key_type = false;
  bool isset_val_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metadata.read(iprot);
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cpp_name);
          this->__isset.cpp_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->key_type);
          isset_key_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->val_type);
          isset_val_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_key_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_val_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t t_map::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("t_map");

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->metadata.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.cpp_name) {
    xfer += oprot->writeFieldBegin("cpp_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->cpp_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("key_type", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->key_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("val_type", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->val_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(t_map &a, t_map &b) {
  using ::std::swap;
  swap(a.metadata, b.metadata);
  swap(a.cpp_name, b.cpp_name);
  swap(a.key_type, b.key_type);
  swap(a.val_type, b.val_type);
  swap(a.__isset, b.__isset);
}

t_map::t_map(const t_map& other17) {
  metadata = other17.metadata;
  cpp_name = other17.cpp_name;
  key_type = other17.key_type;
  val_type = other17.val_type;
  __isset = other17.__isset;
}
t_map& t_map::operator=(const t_map& other18) {
  metadata = other18.metadata;
  cpp_name = other18.cpp_name;
  key_type = other18.key_type;
  val_type = other18.val_type;
  __isset = other18.__isset;
  return *this;
}
void t_map::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "t_map(";
  out << "metadata=" << to_string(metadata);
  out << ", " << "cpp_name="; (__isset.cpp_name ? (out << to_string(cpp_name)) : (out << "<null>"));
  out << ", " << "key_type=" << to_string(key_type);
  out << ", " << "val_type=" << to_string(val_type);
  out << ")";
}


t_typedef::~t_typedef() throw() {
}


void t_typedef::__set_metadata(const TypeMetadata& val) {
  this->metadata = val;
}

void t_typedef::__set_type(const t_type_id val) {
  this->type = val;
}

void t_typedef::__set_symbolic(const std::string& val) {
  this->symbolic = val;
}

void t_typedef::__set_forward(const bool val) {
  this->forward = val;
}

uint32_t t_typedef::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_metadata = false;
  bool isset_type = false;
  bool isset_symbolic = false;
  bool isset_forward = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metadata.read(iprot);
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->type);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->symbolic);
          isset_symbolic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->forward);
          isset_forward = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_symbolic)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_forward)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t t_typedef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("t_typedef");

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->metadata.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("symbolic", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->symbolic);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("forward", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->forward);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(t_typedef &a, t_typedef &b) {
  using ::std::swap;
  swap(a.metadata, b.metadata);
  swap(a.type, b.type);
  swap(a.symbolic, b.symbolic);
  swap(a.forward, b.forward);
}

t_typedef::t_typedef(const t_typedef& other19) {
  metadata = other19.metadata;
  type = other19.type;
  symbolic = other19.symbolic;
  forward = other19.forward;
}
t_typedef& t_typedef::operator=(const t_typedef& other20) {
  metadata = other20.metadata;
  type = other20.type;
  symbolic = other20.symbolic;
  forward = other20.forward;
  return *this;
}
void t_typedef::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "t_typedef(";
  out << "metadata=" << to_string(metadata);
  out << ", " << "type=" << to_string(type);
  out << ", " << "symbolic=" << to_string(symbolic);
  out << ", " << "forward=" << to_string(forward);
  out << ")";
}


t_enum_value::~t_enum_value() throw() {
}


void t_enum_value::__set_name(const std::string& val) {
  this->name = val;
}

void t_enum_value::__set_value(const int32_t val) {
  this->value = val;
}

void t_enum_value::__set_annotations(const std::map<std::string, std::string> & val) {
  this->annotations = val;
__isset.annotations = true;
}

void t_enum_value::__set_doc(const std::string& val) {
  this->doc = val;
__isset.doc = true;
}

uint32_t t_enum_value::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 99:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->annotations.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _ktype22;
            ::apache::thrift::protocol::TType _vtype23;
            xfer += iprot->readMapBegin(_ktype22, _vtype23, _size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
              std::string _key26;
              xfer += iprot->readString(_key26);
              std::string& _val27 = this->annotations[_key26];
              xfer += iprot->readString(_val27);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.annotations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->doc);
          this->__isset.doc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t t_enum_value::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("t_enum_value");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->value);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.annotations) {
    xfer += oprot->writeFieldBegin("annotations", ::apache::thrift::protocol::T_MAP, 99);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->annotations.size()));
      std::map<std::string, std::string> ::const_iterator _iter28;
      for (_iter28 = this->annotations.begin(); _iter28 != this->annotations.end(); ++_iter28)
      {
        xfer += oprot->writeString(_iter28->first);
        xfer += oprot->writeString(_iter28->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.doc) {
    xfer += oprot->writeFieldBegin("doc", ::apache::thrift::protocol::T_STRING, 100);
    xfer += oprot->writeString(this->doc);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(t_enum_value &a, t_enum_value &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.value, b.value);
  swap(a.annotations, b.annotations);
  swap(a.doc, b.doc);
  swap(a.__isset, b.__isset);
}

t_enum_value::t_enum_value(const t_enum_value& other29) {
  name = other29.name;
  value = other29.value;
  annotations = other29.annotations;
  doc = other29.doc;
  __isset = other29.__isset;
}
t_enum_value& t_enum_value::operator=(const t_enum_value& other30) {
  name = other30.name;
  value = other30.value;
  annotations = other30.annotations;
  doc = other30.doc;
  __isset = other30.__isset;
  return *this;
}
void t_enum_value::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "t_enum_value(";
  out << "name=" << to_string(name);
  out << ", " << "value=" << to_string(value);
  out << ", " << "annotations="; (__isset.annotations ? (out << to_string(annotations)) : (out << "<null>"));
  out << ", " << "doc="; (__isset.doc ? (out << to_string(doc)) : (out << "<null>"));
  out << ")";
}


t_enum::~t_enum() throw() {
}


void t_enum::__set_metadata(const TypeMetadata& val) {
  this->metadata = val;
}

void t_enum::__set_constants(const std::vector<t_enum_value> & val) {
  this->constants = val;
}

uint32_t t_enum::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_metadata = false;
  bool isset_constants = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metadata.read(iprot);
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->constants.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->constants.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              xfer += this->constants[_i35].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_constants = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_constants)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t t_enum::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("t_enum");

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->metadata.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("constants", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->constants.size()));
    std::vector<t_enum_value> ::const_iterator _iter36;
    for (_iter36 = this->constants.begin(); _iter36 != this->constants.end(); ++_iter36)
    {
      xfer += (*_iter36).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(t_enum &a, t_enum &b) {
  using ::std::swap;
  swap(a.metadata, b.metadata);
  swap(a.constants, b.constants);
}

t_enum::t_enum(const t_enum& other37) {
  metadata = other37.metadata;
  constants = other37.constants;
}
t_enum& t_enum::operator=(const t_enum& other38) {
  metadata = other38.metadata;
  constants = other38.constants;
  return *this;
}
void t_enum::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "t_enum(";
  out << "metadata=" << to_string(metadata);
  out << ", " << "constants=" << to_string(constants);
  out << ")";
}


t_const_value::~t_const_value() throw() {
}


void t_const_value::__set_map_val(const std::map<t_const_value, t_const_value> & val) {
  this->map_val = val;
__isset.map_val = true;
}

void t_const_value::__set_list_val(const std::vector<t_const_value> & val) {
  this->list_val = val;
__isset.list_val = true;
}

void t_const_value::__set_string_val(const std::string& val) {
  this->string_val = val;
__isset.string_val = true;
}

void t_const_value::__set_integer_val(const int64_t val) {
  this->integer_val = val;
__isset.integer_val = true;
}

void t_const_value::__set_double_val(const double val) {
  this->double_val = val;
__isset.double_val = true;
}

void t_const_value::__set_identifier_val(const std::string& val) {
  this->identifier_val = val;
__isset.identifier_val = true;
}

void t_const_value::__set_enum_val(const t_type_id val) {
  this->enum_val = val;
__isset.enum_val = true;
}

uint32_t t_const_value::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->map_val.clear();
            uint32_t _size39;
            ::apache::thrift::protocol::TType _ktype40;
            ::apache::thrift::protocol::TType _vtype41;
            xfer += iprot->readMapBegin(_ktype40, _vtype41, _size39);
            uint32_t _i43;
            for (_i43 = 0; _i43 < _size39; ++_i43)
            {
              t_const_value _key44;
              xfer += _key44.read(iprot);
              t_const_value& _val45 = this->map_val[_key44];
              xfer += _val45.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.map_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->list_val.clear();
            uint32_t _size46;
            ::apache::thrift::protocol::TType _etype49;
            xfer += iprot->readListBegin(_etype49, _size46);
            this->list_val.resize(_size46);
            uint32_t _i50;
            for (_i50 = 0; _i50 < _size46; ++_i50)
            {
              xfer += this->list_val[_i50].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.list_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->string_val);
          this->__isset.string_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->integer_val);
          this->__isset.integer_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->double_val);
          this->__isset.double_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->identifier_val);
          this->__isset.identifier_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->enum_val);
          this->__isset.enum_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t t_const_value::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("t_const_value");

  if (this->__isset.map_val) {
    xfer += oprot->writeFieldBegin("map_val", ::apache::thrift::protocol::T_MAP, 1);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->map_val.size()));
      std::map<t_const_value, t_const_value> ::const_iterator _iter51;
      for (_iter51 = this->map_val.begin(); _iter51 != this->map_val.end(); ++_iter51)
      {
        xfer += _iter51->first.write(oprot);
        xfer += _iter51->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.list_val) {
    xfer += oprot->writeFieldBegin("list_val", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->list_val.size()));
      std::vector<t_const_value> ::const_iterator _iter52;
      for (_iter52 = this->list_val.begin(); _iter52 != this->list_val.end(); ++_iter52)
      {
        xfer += (*_iter52).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.string_val) {
    xfer += oprot->writeFieldBegin("string_val", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->string_val);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.integer_val) {
    xfer += oprot->writeFieldBegin("integer_val", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->integer_val);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.double_val) {
    xfer += oprot->writeFieldBegin("double_val", ::apache::thrift::protocol::T_DOUBLE, 5);
    xfer += oprot->writeDouble(this->double_val);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.identifier_val) {
    xfer += oprot->writeFieldBegin("identifier_val", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->identifier_val);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.enum_val) {
    xfer += oprot->writeFieldBegin("enum_val", ::apache::thrift::protocol::T_I64, 7);
    xfer += oprot->writeI64(this->enum_val);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(t_const_value &a, t_const_value &b) {
  using ::std::swap;
  swap(a.map_val, b.map_val);
  swap(a.list_val, b.list_val);
  swap(a.string_val, b.string_val);
  swap(a.integer_val, b.integer_val);
  swap(a.double_val, b.double_val);
  swap(a.identifier_val, b.identifier_val);
  swap(a.enum_val, b.enum_val);
  swap(a.__isset, b.__isset);
}

t_const_value::t_const_value(const t_const_value& other53) {
  map_val = other53.map_val;
  list_val = other53.list_val;
  string_val = other53.string_val;
  integer_val = other53.integer_val;
  double_val = other53.double_val;
  identifier_val = other53.identifier_val;
  enum_val = other53.enum_val;
  __isset = other53.__isset;
}
t_const_value& t_const_value::operator=(const t_const_value& other54) {
  map_val = other54.map_val;
  list_val = other54.list_val;
  string_val = other54.string_val;
  integer_val = other54.integer_val;
  double_val = other54.double_val;
  identifier_val = other54.identifier_val;
  enum_val = other54.enum_val;
  __isset = other54.__isset;
  return *this;
}
void t_const_value::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "t_const_value(";
  out << "map_val="; (__isset.map_val ? (out << to_string(map_val)) : (out << "<null>"));
  out << ", " << "list_val="; (__isset.list_val ? (out << to_string(list_val)) : (out << "<null>"));
  out << ", " << "string_val="; (__isset.string_val ? (out << to_string(string_val)) : (out << "<null>"));
  out << ", " << "integer_val="; (__isset.integer_val ? (out << to_string(integer_val)) : (out << "<null>"));
  out << ", " << "double_val="; (__isset.double_val ? (out << to_string(double_val)) : (out << "<null>"));
  out << ", " << "identifier_val="; (__isset.identifier_val ? (out << to_string(identifier_val)) : (out << "<null>"));
  out << ", " << "enum_val="; (__isset.enum_val ? (out << to_string(enum_val)) : (out << "<null>"));
  out << ")";
}


t_const::~t_const() throw() {
}


void t_const::__set_name(const std::string& val) {
  this->name = val;
}

void t_const::__set_type(const t_type_id val) {
  this->type = val;
}

void t_const::__set_value(const t_const_value& val) {
  this->value = val;
}

void t_const::__set_doc(const std::string& val) {
  this->doc = val;
__isset.doc = true;
}

uint32_t t_const::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_type = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->type);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->value.read(iprot);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->doc);
          this->__isset.doc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t t_const::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("t_const");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->value.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.doc) {
    xfer += oprot->writeFieldBegin("doc", ::apache::thrift::protocol::T_STRING, 100);
    xfer += oprot->writeString(this->doc);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(t_const &a, t_const &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.value, b.value);
  swap(a.doc, b.doc);
  swap(a.__isset, b.__isset);
}

t_const::t_const(const t_const& other55) {
  name = other55.name;
  type = other55.type;
  value = other55.value;
  doc = other55.doc;
  __isset = other55.__isset;
}
t_const& t_const::operator=(const t_const& other56) {
  name = other56.name;
  type = other56.type;
  value = other56.value;
  doc = other56.doc;
  __isset = other56.__isset;
  return *this;
}
void t_const::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "t_const(";
  out << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "value=" << to_string(value);
  out << ", " << "doc="; (__isset.doc ? (out << to_string(doc)) : (out << "<null>"));
  out << ")";
}


t_struct::~t_struct() throw() {
}


void t_struct::__set_metadata(const TypeMetadata& val) {
  this->metadata = val;
}

void t_struct::__set_members(const std::vector<t_field> & val) {
  this->members = val;
}

void t_struct::__set_is_union(const bool val) {
  this->is_union = val;
}

void t_struct::__set_is_xception(const bool val) {
  this->is_xception = val;
}

uint32_t t_struct::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_metadata = false;
  bool isset_members = false;
  bool isset_is_union = false;
  bool isset_is_xception = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metadata.read(iprot);
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->members.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _etype60;
            xfer += iprot->readListBegin(_etype60, _size57);
            this->members.resize(_size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              xfer += this->members[_i61].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_members = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_union);
          isset_is_union = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_xception);
          isset_is_xception = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_members)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_union)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_xception)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t t_struct::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("t_struct");

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->metadata.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("members", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->members.size()));
    std::vector<t_field> ::const_iterator _iter62;
    for (_iter62 = this->members.begin(); _iter62 != this->members.end(); ++_iter62)
    {
      xfer += (*_iter62).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_union", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_union);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_xception", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_xception);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(t_struct &a, t_struct &b) {
  using ::std::swap;
  swap(a.metadata, b.metadata);
  swap(a.members, b.members);
  swap(a.is_union, b.is_union);
  swap(a.is_xception, b.is_xception);
}

t_struct::t_struct(const t_struct& other63) {
  metadata = other63.metadata;
  members = other63.members;
  is_union = other63.is_union;
  is_xception = other63.is_xception;
}
t_struct& t_struct::operator=(const t_struct& other64) {
  metadata = other64.metadata;
  members = other64.members;
  is_union = other64.is_union;
  is_xception = other64.is_xception;
  return *this;
}
void t_struct::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "t_struct(";
  out << "metadata=" << to_string(metadata);
  out << ", " << "members=" << to_string(members);
  out << ", " << "is_union=" << to_string(is_union);
  out << ", " << "is_xception=" << to_string(is_xception);
  out << ")";
}


t_field::~t_field() throw() {
}


void t_field::__set_name(const std::string& val) {
  this->name = val;
}

void t_field::__set_type(const t_type_id val) {
  this->type = val;
}

void t_field::__set_key(const int32_t val) {
  this->key = val;
}

void t_field::__set_req(const Requiredness::type val) {
  this->req = val;
}

void t_field::__set_value(const t_const_value& val) {
  this->value = val;
__isset.value = true;
}

void t_field::__set_reference(const bool val) {
  this->reference = val;
}

void t_field::__set_annotations(const std::map<std::string, std::string> & val) {
  this->annotations = val;
__isset.annotations = true;
}

void t_field::__set_doc(const std::string& val) {
  this->doc = val;
__isset.doc = true;
}

uint32_t t_field::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_type = false;
  bool isset_key = false;
  bool isset_req = false;
  bool isset_reference = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->type);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->key);
          isset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast65;
          xfer += iprot->readI32(ecast65);
          this->req = (Requiredness::type)ecast65;
          isset_req = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->value.read(iprot);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->reference);
          isset_reference = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 99:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->annotations.clear();
            uint32_t _size66;
            ::apache::thrift::protocol::TType _ktype67;
            ::apache::thrift::protocol::TType _vtype68;
            xfer += iprot->readMapBegin(_ktype67, _vtype68, _size66);
            uint32_t _i70;
            for (_i70 = 0; _i70 < _size66; ++_i70)
            {
              std::string _key71;
              xfer += iprot->readString(_key71);
              std::string& _val72 = this->annotations[_key71];
              xfer += iprot->readString(_val72);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.annotations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->doc);
          this->__isset.doc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_req)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_reference)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t t_field::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("t_field");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("req", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->req);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->value.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("reference", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->reference);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.annotations) {
    xfer += oprot->writeFieldBegin("annotations", ::apache::thrift::protocol::T_MAP, 99);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->annotations.size()));
      std::map<std::string, std::string> ::const_iterator _iter73;
      for (_iter73 = this->annotations.begin(); _iter73 != this->annotations.end(); ++_iter73)
      {
        xfer += oprot->writeString(_iter73->first);
        xfer += oprot->writeString(_iter73->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.doc) {
    xfer += oprot->writeFieldBegin("doc", ::apache::thrift::protocol::T_STRING, 100);
    xfer += oprot->writeString(this->doc);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(t_field &a, t_field &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.key, b.key);
  swap(a.req, b.req);
  swap(a.value, b.value);
  swap(a.reference, b.reference);
  swap(a.annotations, b.annotations);
  swap(a.doc, b.doc);
  swap(a.__isset, b.__isset);
}

t_field::t_field(const t_field& other74) {
  name = other74.name;
  type = other74.type;
  key = other74.key;
  req = other74.req;
  value = other74.value;
  reference = other74.reference;
  annotations = other74.annotations;
  doc = other74.doc;
  __isset = other74.__isset;
}
t_field& t_field::operator=(const t_field& other75) {
  name = other75.name;
  type = other75.type;
  key = other75.key;
  req = other75.req;
  value = other75.value;
  reference = other75.reference;
  annotations = other75.annotations;
  doc = other75.doc;
  __isset = other75.__isset;
  return *this;
}
void t_field::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "t_field(";
  out << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "key=" << to_string(key);
  out << ", " << "req=" << to_string(req);
  out << ", " << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ", " << "reference=" << to_string(reference);
  out << ", " << "annotations="; (__isset.annotations ? (out << to_string(annotations)) : (out << "<null>"));
  out << ", " << "doc="; (__isset.doc ? (out << to_string(doc)) : (out << "<null>"));
  out << ")";
}


t_function::~t_function() throw() {
}


void t_function::__set_name(const std::string& val) {
  this->name = val;
}

void t_function::__set_returntype(const t_type_id val) {
  this->returntype = val;
}

void t_function::__set_arglist(const t_type_id val) {
  this->arglist = val;
}

void t_function::__set_xceptions(const t_type_id val) {
  this->xceptions = val;
}

void t_function::__set_is_oneway(const bool val) {
  this->is_oneway = val;
}

void t_function::__set_doc(const std::string& val) {
  this->doc = val;
__isset.doc = true;
}

uint32_t t_function::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_returntype = false;
  bool isset_arglist = false;
  bool isset_xceptions = false;
  bool isset_is_oneway = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->returntype);
          isset_returntype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->arglist);
          isset_arglist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->xceptions);
          isset_xceptions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_oneway);
          isset_is_oneway = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->doc);
          this->__isset.doc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_returntype)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_arglist)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_xceptions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_is_oneway)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t t_function::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("t_function");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("returntype", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->returntype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arglist", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->arglist);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xceptions", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->xceptions);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_oneway", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_oneway);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.doc) {
    xfer += oprot->writeFieldBegin("doc", ::apache::thrift::protocol::T_STRING, 100);
    xfer += oprot->writeString(this->doc);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(t_function &a, t_function &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.returntype, b.returntype);
  swap(a.arglist, b.arglist);
  swap(a.xceptions, b.xceptions);
  swap(a.is_oneway, b.is_oneway);
  swap(a.doc, b.doc);
  swap(a.__isset, b.__isset);
}

t_function::t_function(const t_function& other76) {
  name = other76.name;
  returntype = other76.returntype;
  arglist = other76.arglist;
  xceptions = other76.xceptions;
  is_oneway = other76.is_oneway;
  doc = other76.doc;
  __isset = other76.__isset;
}
t_function& t_function::operator=(const t_function& other77) {
  name = other77.name;
  returntype = other77.returntype;
  arglist = other77.arglist;
  xceptions = other77.xceptions;
  is_oneway = other77.is_oneway;
  doc = other77.doc;
  __isset = other77.__isset;
  return *this;
}
void t_function::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "t_function(";
  out << "name=" << to_string(name);
  out << ", " << "returntype=" << to_string(returntype);
  out << ", " << "arglist=" << to_string(arglist);
  out << ", " << "xceptions=" << to_string(xceptions);
  out << ", " << "is_oneway=" << to_string(is_oneway);
  out << ", " << "doc="; (__isset.doc ? (out << to_string(doc)) : (out << "<null>"));
  out << ")";
}


t_service::~t_service() throw() {
}


void t_service::__set_metadata(const TypeMetadata& val) {
  this->metadata = val;
}

void t_service::__set_functions(const std::vector<t_function> & val) {
  this->functions = val;
}

void t_service::__set_extends_(const t_service_id val) {
  this->extends_ = val;
__isset.extends_ = true;
}

uint32_t t_service::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_metadata = false;
  bool isset_functions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->metadata.read(iprot);
          isset_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->functions.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            xfer += iprot->readListBegin(_etype81, _size78);
            this->functions.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += this->functions[_i82].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_functions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->extends_);
          this->__isset.extends_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_metadata)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_functions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t t_service::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("t_service");

  xfer += oprot->writeFieldBegin("metadata", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->metadata.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("functions", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->functions.size()));
    std::vector<t_function> ::const_iterator _iter83;
    for (_iter83 = this->functions.begin(); _iter83 != this->functions.end(); ++_iter83)
    {
      xfer += (*_iter83).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.extends_) {
    xfer += oprot->writeFieldBegin("extends_", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->extends_);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(t_service &a, t_service &b) {
  using ::std::swap;
  swap(a.metadata, b.metadata);
  swap(a.functions, b.functions);
  swap(a.extends_, b.extends_);
  swap(a.__isset, b.__isset);
}

t_service::t_service(const t_service& other84) {
  metadata = other84.metadata;
  functions = other84.functions;
  extends_ = other84.extends_;
  __isset = other84.__isset;
}
t_service& t_service::operator=(const t_service& other85) {
  metadata = other85.metadata;
  functions = other85.functions;
  extends_ = other85.extends_;
  __isset = other85.__isset;
  return *this;
}
void t_service::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "t_service(";
  out << "metadata=" << to_string(metadata);
  out << ", " << "functions=" << to_string(functions);
  out << ", " << "extends_="; (__isset.extends_ ? (out << to_string(extends_)) : (out << "<null>"));
  out << ")";
}


t_type::~t_type() throw() {
}


void t_type::__set_base_type_val(const t_base_type& val) {
  this->base_type_val = val;
__isset.base_type_val = true;
}

void t_type::__set_typedef_val(const t_typedef& val) {
  this->typedef_val = val;
__isset.typedef_val = true;
}

void t_type::__set_enum_val(const t_enum& val) {
  this->enum_val = val;
__isset.enum_val = true;
}

void t_type::__set_struct_val(const t_struct& val) {
  this->struct_val = val;
__isset.struct_val = true;
}

void t_type::__set_xception_val(const t_struct& val) {
  this->xception_val = val;
__isset.xception_val = true;
}

void t_type::__set_list_val(const t_list& val) {
  this->list_val = val;
__isset.list_val = true;
}

void t_type::__set_set_val(const t_set& val) {
  this->set_val = val;
__isset.set_val = true;
}

void t_type::__set_map_val(const t_map& val) {
  this->map_val = val;
__isset.map_val = true;
}

void t_type::__set_service_val(const t_service& val) {
  this->service_val = val;
__isset.service_val = true;
}

uint32_t t_type::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->base_type_val.read(iprot);
          this->__isset.base_type_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->typedef_val.read(iprot);
          this->__isset.typedef_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->enum_val.read(iprot);
          this->__isset.enum_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->struct_val.read(iprot);
          this->__isset.struct_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->xception_val.read(iprot);
          this->__isset.xception_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->list_val.read(iprot);
          this->__isset.list_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->set_val.read(iprot);
          this->__isset.set_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->map_val.read(iprot);
          this->__isset.map_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->service_val.read(iprot);
          this->__isset.service_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t t_type::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("t_type");

  if (this->__isset.base_type_val) {
    xfer += oprot->writeFieldBegin("base_type_val", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->base_type_val.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.typedef_val) {
    xfer += oprot->writeFieldBegin("typedef_val", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->typedef_val.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.enum_val) {
    xfer += oprot->writeFieldBegin("enum_val", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->enum_val.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.struct_val) {
    xfer += oprot->writeFieldBegin("struct_val", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->struct_val.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.xception_val) {
    xfer += oprot->writeFieldBegin("xception_val", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->xception_val.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.list_val) {
    xfer += oprot->writeFieldBegin("list_val", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->list_val.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.set_val) {
    xfer += oprot->writeFieldBegin("set_val", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->set_val.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.map_val) {
    xfer += oprot->writeFieldBegin("map_val", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->map_val.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.service_val) {
    xfer += oprot->writeFieldBegin("service_val", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->service_val.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(t_type &a, t_type &b) {
  using ::std::swap;
  swap(a.base_type_val, b.base_type_val);
  swap(a.typedef_val, b.typedef_val);
  swap(a.enum_val, b.enum_val);
  swap(a.struct_val, b.struct_val);
  swap(a.xception_val, b.xception_val);
  swap(a.list_val, b.list_val);
  swap(a.set_val, b.set_val);
  swap(a.map_val, b.map_val);
  swap(a.service_val, b.service_val);
  swap(a.__isset, b.__isset);
}

t_type::t_type(const t_type& other86) {
  base_type_val = other86.base_type_val;
  typedef_val = other86.typedef_val;
  enum_val = other86.enum_val;
  struct_val = other86.struct_val;
  xception_val = other86.xception_val;
  list_val = other86.list_val;
  set_val = other86.set_val;
  map_val = other86.map_val;
  service_val = other86.service_val;
  __isset = other86.__isset;
}
t_type& t_type::operator=(const t_type& other87) {
  base_type_val = other87.base_type_val;
  typedef_val = other87.typedef_val;
  enum_val = other87.enum_val;
  struct_val = other87.struct_val;
  xception_val = other87.xception_val;
  list_val = other87.list_val;
  set_val = other87.set_val;
  map_val = other87.map_val;
  service_val = other87.service_val;
  __isset = other87.__isset;
  return *this;
}
void t_type::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "t_type(";
  out << "base_type_val="; (__isset.base_type_val ? (out << to_string(base_type_val)) : (out << "<null>"));
  out << ", " << "typedef_val="; (__isset.typedef_val ? (out << to_string(typedef_val)) : (out << "<null>"));
  out << ", " << "enum_val="; (__isset.enum_val ? (out << to_string(enum_val)) : (out << "<null>"));
  out << ", " << "struct_val="; (__isset.struct_val ? (out << to_string(struct_val)) : (out << "<null>"));
  out << ", " << "xception_val="; (__isset.xception_val ? (out << to_string(xception_val)) : (out << "<null>"));
  out << ", " << "list_val="; (__isset.list_val ? (out << to_string(list_val)) : (out << "<null>"));
  out << ", " << "set_val="; (__isset.set_val ? (out << to_string(set_val)) : (out << "<null>"));
  out << ", " << "map_val="; (__isset.map_val ? (out << to_string(map_val)) : (out << "<null>"));
  out << ", " << "service_val="; (__isset.service_val ? (out << to_string(service_val)) : (out << "<null>"));
  out << ")";
}


t_scope::~t_scope() throw() {
}


void t_scope::__set_types(const std::vector<t_type_id> & val) {
  this->types = val;
}

void t_scope::__set_constants(const std::vector<t_const_id> & val) {
  this->constants = val;
}

void t_scope::__set_services(const std::vector<t_service_id> & val) {
  this->services = val;
}

uint32_t t_scope::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_types = false;
  bool isset_constants = false;
  bool isset_services = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->types.clear();
            uint32_t _size88;
            ::apache::thrift::protocol::TType _etype91;
            xfer += iprot->readListBegin(_etype91, _size88);
            this->types.resize(_size88);
            uint32_t _i92;
            for (_i92 = 0; _i92 < _size88; ++_i92)
            {
              xfer += iprot->readI64(this->types[_i92]);
            }
            xfer += iprot->readListEnd();
          }
          isset_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->constants.clear();
            uint32_t _size93;
            ::apache::thrift::protocol::TType _etype96;
            xfer += iprot->readListBegin(_etype96, _size93);
            this->constants.resize(_size93);
            uint32_t _i97;
            for (_i97 = 0; _i97 < _size93; ++_i97)
            {
              xfer += iprot->readI64(this->constants[_i97]);
            }
            xfer += iprot->readListEnd();
          }
          isset_constants = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->services.clear();
            uint32_t _size98;
            ::apache::thrift::protocol::TType _etype101;
            xfer += iprot->readListBegin(_etype101, _size98);
            this->services.resize(_size98);
            uint32_t _i102;
            for (_i102 = 0; _i102 < _size98; ++_i102)
            {
              xfer += iprot->readI64(this->services[_i102]);
            }
            xfer += iprot->readListEnd();
          }
          isset_services = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_constants)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_services)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t t_scope::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("t_scope");

  xfer += oprot->writeFieldBegin("types", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->types.size()));
    std::vector<t_type_id> ::const_iterator _iter103;
    for (_iter103 = this->types.begin(); _iter103 != this->types.end(); ++_iter103)
    {
      xfer += oprot->writeI64((*_iter103));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("constants", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->constants.size()));
    std::vector<t_const_id> ::const_iterator _iter104;
    for (_iter104 = this->constants.begin(); _iter104 != this->constants.end(); ++_iter104)
    {
      xfer += oprot->writeI64((*_iter104));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("services", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->services.size()));
    std::vector<t_service_id> ::const_iterator _iter105;
    for (_iter105 = this->services.begin(); _iter105 != this->services.end(); ++_iter105)
    {
      xfer += oprot->writeI64((*_iter105));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(t_scope &a, t_scope &b) {
  using ::std::swap;
  swap(a.types, b.types);
  swap(a.constants, b.constants);
  swap(a.services, b.services);
}

t_scope::t_scope(const t_scope& other106) {
  types = other106.types;
  constants = other106.constants;
  services = other106.services;
}
t_scope& t_scope::operator=(const t_scope& other107) {
  types = other107.types;
  constants = other107.constants;
  services = other107.services;
  return *this;
}
void t_scope::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "t_scope(";
  out << "types=" << to_string(types);
  out << ", " << "constants=" << to_string(constants);
  out << ", " << "services=" << to_string(services);
  out << ")";
}


TypeRegistry::~TypeRegistry() throw() {
}


void TypeRegistry::__set_types(const std::map<t_type_id, t_type> & val) {
  this->types = val;
}

void TypeRegistry::__set_constants(const std::map<t_const_id, t_const> & val) {
  this->constants = val;
}

void TypeRegistry::__set_services(const std::map<t_service_id, t_service> & val) {
  this->services = val;
}

uint32_t TypeRegistry::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_types = false;
  bool isset_constants = false;
  bool isset_services = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->types.clear();
            uint32_t _size108;
            ::apache::thrift::protocol::TType _ktype109;
            ::apache::thrift::protocol::TType _vtype110;
            xfer += iprot->readMapBegin(_ktype109, _vtype110, _size108);
            uint32_t _i112;
            for (_i112 = 0; _i112 < _size108; ++_i112)
            {
              t_type_id _key113;
              xfer += iprot->readI64(_key113);
              t_type& _val114 = this->types[_key113];
              xfer += _val114.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->constants.clear();
            uint32_t _size115;
            ::apache::thrift::protocol::TType _ktype116;
            ::apache::thrift::protocol::TType _vtype117;
            xfer += iprot->readMapBegin(_ktype116, _vtype117, _size115);
            uint32_t _i119;
            for (_i119 = 0; _i119 < _size115; ++_i119)
            {
              t_const_id _key120;
              xfer += iprot->readI64(_key120);
              t_const& _val121 = this->constants[_key120];
              xfer += _val121.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_constants = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->services.clear();
            uint32_t _size122;
            ::apache::thrift::protocol::TType _ktype123;
            ::apache::thrift::protocol::TType _vtype124;
            xfer += iprot->readMapBegin(_ktype123, _vtype124, _size122);
            uint32_t _i126;
            for (_i126 = 0; _i126 < _size122; ++_i126)
            {
              t_service_id _key127;
              xfer += iprot->readI64(_key127);
              t_service& _val128 = this->services[_key127];
              xfer += _val128.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_services = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_constants)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_services)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TypeRegistry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TypeRegistry");

  xfer += oprot->writeFieldBegin("types", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->types.size()));
    std::map<t_type_id, t_type> ::const_iterator _iter129;
    for (_iter129 = this->types.begin(); _iter129 != this->types.end(); ++_iter129)
    {
      xfer += oprot->writeI64(_iter129->first);
      xfer += _iter129->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("constants", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->constants.size()));
    std::map<t_const_id, t_const> ::const_iterator _iter130;
    for (_iter130 = this->constants.begin(); _iter130 != this->constants.end(); ++_iter130)
    {
      xfer += oprot->writeI64(_iter130->first);
      xfer += _iter130->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("services", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->services.size()));
    std::map<t_service_id, t_service> ::const_iterator _iter131;
    for (_iter131 = this->services.begin(); _iter131 != this->services.end(); ++_iter131)
    {
      xfer += oprot->writeI64(_iter131->first);
      xfer += _iter131->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TypeRegistry &a, TypeRegistry &b) {
  using ::std::swap;
  swap(a.types, b.types);
  swap(a.constants, b.constants);
  swap(a.services, b.services);
}

TypeRegistry::TypeRegistry(const TypeRegistry& other132) {
  types = other132.types;
  constants = other132.constants;
  services = other132.services;
}
TypeRegistry& TypeRegistry::operator=(const TypeRegistry& other133) {
  types = other133.types;
  constants = other133.constants;
  services = other133.services;
  return *this;
}
void TypeRegistry::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TypeRegistry(";
  out << "types=" << to_string(types);
  out << ", " << "constants=" << to_string(constants);
  out << ", " << "services=" << to_string(services);
  out << ")";
}


t_program::~t_program() throw() {
}


void t_program::__set_name(const std::string& val) {
  this->name = val;
}

void t_program::__set_program_id(const t_program_id val) {
  this->program_id = val;
}

void t_program::__set_path(const std::string& val) {
  this->path = val;
}

void t_program::__set_namespace_(const std::string& val) {
  this->namespace_ = val;
}

void t_program::__set_out_path(const std::string& val) {
  this->out_path = val;
}

void t_program::__set_out_path_is_absolute(const bool val) {
  this->out_path_is_absolute = val;
}

void t_program::__set_includes(const std::vector<t_program> & val) {
  this->includes = val;
}

void t_program::__set_include_prefix(const std::string& val) {
  this->include_prefix = val;
}

void t_program::__set_scope(const t_scope& val) {
  this->scope = val;
}

void t_program::__set_typedefs(const std::vector<t_type_id> & val) {
  this->typedefs = val;
}

void t_program::__set_enums(const std::vector<t_type_id> & val) {
  this->enums = val;
}

void t_program::__set_consts(const std::vector<t_const_id> & val) {
  this->consts = val;
}

void t_program::__set_objects(const std::vector<t_type_id> & val) {
  this->objects = val;
}

void t_program::__set_services(const std::vector<t_service_id> & val) {
  this->services = val;
}

void t_program::__set_namespaces(const std::map<std::string, std::string> & val) {
  this->namespaces = val;
}

void t_program::__set_cpp_includes(const std::vector<std::string> & val) {
  this->cpp_includes = val;
}

void t_program::__set_c_includes(const std::vector<std::string> & val) {
  this->c_includes = val;
}

void t_program::__set_doc(const std::string& val) {
  this->doc = val;
__isset.doc = true;
}

uint32_t t_program::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_program_id = false;
  bool isset_path = false;
  bool isset_namespace_ = false;
  bool isset_out_path = false;
  bool isset_out_path_is_absolute = false;
  bool isset_includes = false;
  bool isset_include_prefix = false;
  bool isset_scope = false;
  bool isset_typedefs = false;
  bool isset_enums = false;
  bool isset_consts = false;
  bool isset_objects = false;
  bool isset_services = false;
  bool isset_namespaces = false;
  bool isset_cpp_includes = false;
  bool isset_c_includes = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->program_id);
          isset_program_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          isset_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->namespace_);
          isset_namespace_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->out_path);
          isset_out_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->out_path_is_absolute);
          isset_out_path_is_absolute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->includes.clear();
            uint32_t _size134;
            ::apache::thrift::protocol::TType _etype137;
            xfer += iprot->readListBegin(_etype137, _size134);
            this->includes.resize(_size134);
            uint32_t _i138;
            for (_i138 = 0; _i138 < _size134; ++_i138)
            {
              xfer += this->includes[_i138].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_includes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->include_prefix);
          isset_include_prefix = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->scope.read(iprot);
          isset_scope = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->typedefs.clear();
            uint32_t _size139;
            ::apache::thrift::protocol::TType _etype142;
            xfer += iprot->readListBegin(_etype142, _size139);
            this->typedefs.resize(_size139);
            uint32_t _i143;
            for (_i143 = 0; _i143 < _size139; ++_i143)
            {
              xfer += iprot->readI64(this->typedefs[_i143]);
            }
            xfer += iprot->readListEnd();
          }
          isset_typedefs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->enums.clear();
            uint32_t _size144;
            ::apache::thrift::protocol::TType _etype147;
            xfer += iprot->readListBegin(_etype147, _size144);
            this->enums.resize(_size144);
            uint32_t _i148;
            for (_i148 = 0; _i148 < _size144; ++_i148)
            {
              xfer += iprot->readI64(this->enums[_i148]);
            }
            xfer += iprot->readListEnd();
          }
          isset_enums = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->consts.clear();
            uint32_t _size149;
            ::apache::thrift::protocol::TType _etype152;
            xfer += iprot->readListBegin(_etype152, _size149);
            this->consts.resize(_size149);
            uint32_t _i153;
            for (_i153 = 0; _i153 < _size149; ++_i153)
            {
              xfer += iprot->readI64(this->consts[_i153]);
            }
            xfer += iprot->readListEnd();
          }
          isset_consts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->objects.clear();
            uint32_t _size154;
            ::apache::thrift::protocol::TType _etype157;
            xfer += iprot->readListBegin(_etype157, _size154);
            this->objects.resize(_size154);
            uint32_t _i158;
            for (_i158 = 0; _i158 < _size154; ++_i158)
            {
              xfer += iprot->readI64(this->objects[_i158]);
            }
            xfer += iprot->readListEnd();
          }
          isset_objects = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->services.clear();
            uint32_t _size159;
            ::apache::thrift::protocol::TType _etype162;
            xfer += iprot->readListBegin(_etype162, _size159);
            this->services.resize(_size159);
            uint32_t _i163;
            for (_i163 = 0; _i163 < _size159; ++_i163)
            {
              xfer += iprot->readI64(this->services[_i163]);
            }
            xfer += iprot->readListEnd();
          }
          isset_services = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->namespaces.clear();
            uint32_t _size164;
            ::apache::thrift::protocol::TType _ktype165;
            ::apache::thrift::protocol::TType _vtype166;
            xfer += iprot->readMapBegin(_ktype165, _vtype166, _size164);
            uint32_t _i168;
            for (_i168 = 0; _i168 < _size164; ++_i168)
            {
              std::string _key169;
              xfer += iprot->readString(_key169);
              std::string& _val170 = this->namespaces[_key169];
              xfer += iprot->readString(_val170);
            }
            xfer += iprot->readMapEnd();
          }
          isset_namespaces = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cpp_includes.clear();
            uint32_t _size171;
            ::apache::thrift::protocol::TType _etype174;
            xfer += iprot->readListBegin(_etype174, _size171);
            this->cpp_includes.resize(_size171);
            uint32_t _i175;
            for (_i175 = 0; _i175 < _size171; ++_i175)
            {
              xfer += iprot->readString(this->cpp_includes[_i175]);
            }
            xfer += iprot->readListEnd();
          }
          isset_cpp_includes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->c_includes.clear();
            uint32_t _size176;
            ::apache::thrift::protocol::TType _etype179;
            xfer += iprot->readListBegin(_etype179, _size176);
            this->c_includes.resize(_size176);
            uint32_t _i180;
            for (_i180 = 0; _i180 < _size176; ++_i180)
            {
              xfer += iprot->readString(this->c_includes[_i180]);
            }
            xfer += iprot->readListEnd();
          }
          isset_c_includes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->doc);
          this->__isset.doc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_program_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_namespace_)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_out_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_out_path_is_absolute)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_includes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_include_prefix)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_scope)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_typedefs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_enums)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_consts)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_objects)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_services)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_namespaces)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_cpp_includes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_c_includes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t t_program::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("t_program");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("program_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->program_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("namespace_", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->namespace_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("out_path", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->out_path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("out_path_is_absolute", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->out_path_is_absolute);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("includes", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->includes.size()));
    std::vector<t_program> ::const_iterator _iter181;
    for (_iter181 = this->includes.begin(); _iter181 != this->includes.end(); ++_iter181)
    {
      xfer += (*_iter181).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("include_prefix", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->include_prefix);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scope", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->scope.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("typedefs", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->typedefs.size()));
    std::vector<t_type_id> ::const_iterator _iter182;
    for (_iter182 = this->typedefs.begin(); _iter182 != this->typedefs.end(); ++_iter182)
    {
      xfer += oprot->writeI64((*_iter182));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enums", ::apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->enums.size()));
    std::vector<t_type_id> ::const_iterator _iter183;
    for (_iter183 = this->enums.begin(); _iter183 != this->enums.end(); ++_iter183)
    {
      xfer += oprot->writeI64((*_iter183));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("consts", ::apache::thrift::protocol::T_LIST, 13);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->consts.size()));
    std::vector<t_const_id> ::const_iterator _iter184;
    for (_iter184 = this->consts.begin(); _iter184 != this->consts.end(); ++_iter184)
    {
      xfer += oprot->writeI64((*_iter184));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("objects", ::apache::thrift::protocol::T_LIST, 14);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->objects.size()));
    std::vector<t_type_id> ::const_iterator _iter185;
    for (_iter185 = this->objects.begin(); _iter185 != this->objects.end(); ++_iter185)
    {
      xfer += oprot->writeI64((*_iter185));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("services", ::apache::thrift::protocol::T_LIST, 15);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->services.size()));
    std::vector<t_service_id> ::const_iterator _iter186;
    for (_iter186 = this->services.begin(); _iter186 != this->services.end(); ++_iter186)
    {
      xfer += oprot->writeI64((*_iter186));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("namespaces", ::apache::thrift::protocol::T_MAP, 16);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->namespaces.size()));
    std::map<std::string, std::string> ::const_iterator _iter187;
    for (_iter187 = this->namespaces.begin(); _iter187 != this->namespaces.end(); ++_iter187)
    {
      xfer += oprot->writeString(_iter187->first);
      xfer += oprot->writeString(_iter187->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cpp_includes", ::apache::thrift::protocol::T_LIST, 17);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->cpp_includes.size()));
    std::vector<std::string> ::const_iterator _iter188;
    for (_iter188 = this->cpp_includes.begin(); _iter188 != this->cpp_includes.end(); ++_iter188)
    {
      xfer += oprot->writeString((*_iter188));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("c_includes", ::apache::thrift::protocol::T_LIST, 18);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->c_includes.size()));
    std::vector<std::string> ::const_iterator _iter189;
    for (_iter189 = this->c_includes.begin(); _iter189 != this->c_includes.end(); ++_iter189)
    {
      xfer += oprot->writeString((*_iter189));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.doc) {
    xfer += oprot->writeFieldBegin("doc", ::apache::thrift::protocol::T_STRING, 100);
    xfer += oprot->writeString(this->doc);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(t_program &a, t_program &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.program_id, b.program_id);
  swap(a.path, b.path);
  swap(a.namespace_, b.namespace_);
  swap(a.out_path, b.out_path);
  swap(a.out_path_is_absolute, b.out_path_is_absolute);
  swap(a.includes, b.includes);
  swap(a.include_prefix, b.include_prefix);
  swap(a.scope, b.scope);
  swap(a.typedefs, b.typedefs);
  swap(a.enums, b.enums);
  swap(a.consts, b.consts);
  swap(a.objects, b.objects);
  swap(a.services, b.services);
  swap(a.namespaces, b.namespaces);
  swap(a.cpp_includes, b.cpp_includes);
  swap(a.c_includes, b.c_includes);
  swap(a.doc, b.doc);
  swap(a.__isset, b.__isset);
}

t_program::t_program(const t_program& other190) {
  name = other190.name;
  program_id = other190.program_id;
  path = other190.path;
  namespace_ = other190.namespace_;
  out_path = other190.out_path;
  out_path_is_absolute = other190.out_path_is_absolute;
  includes = other190.includes;
  include_prefix = other190.include_prefix;
  scope = other190.scope;
  typedefs = other190.typedefs;
  enums = other190.enums;
  consts = other190.consts;
  objects = other190.objects;
  services = other190.services;
  namespaces = other190.namespaces;
  cpp_includes = other190.cpp_includes;
  c_includes = other190.c_includes;
  doc = other190.doc;
  __isset = other190.__isset;
}
t_program& t_program::operator=(const t_program& other191) {
  name = other191.name;
  program_id = other191.program_id;
  path = other191.path;
  namespace_ = other191.namespace_;
  out_path = other191.out_path;
  out_path_is_absolute = other191.out_path_is_absolute;
  includes = other191.includes;
  include_prefix = other191.include_prefix;
  scope = other191.scope;
  typedefs = other191.typedefs;
  enums = other191.enums;
  consts = other191.consts;
  objects = other191.objects;
  services = other191.services;
  namespaces = other191.namespaces;
  cpp_includes = other191.cpp_includes;
  c_includes = other191.c_includes;
  doc = other191.doc;
  __isset = other191.__isset;
  return *this;
}
void t_program::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "t_program(";
  out << "name=" << to_string(name);
  out << ", " << "program_id=" << to_string(program_id);
  out << ", " << "path=" << to_string(path);
  out << ", " << "namespace_=" << to_string(namespace_);
  out << ", " << "out_path=" << to_string(out_path);
  out << ", " << "out_path_is_absolute=" << to_string(out_path_is_absolute);
  out << ", " << "includes=" << to_string(includes);
  out << ", " << "include_prefix=" << to_string(include_prefix);
  out << ", " << "scope=" << to_string(scope);
  out << ", " << "typedefs=" << to_string(typedefs);
  out << ", " << "enums=" << to_string(enums);
  out << ", " << "consts=" << to_string(consts);
  out << ", " << "objects=" << to_string(objects);
  out << ", " << "services=" << to_string(services);
  out << ", " << "namespaces=" << to_string(namespaces);
  out << ", " << "cpp_includes=" << to_string(cpp_includes);
  out << ", " << "c_includes=" << to_string(c_includes);
  out << ", " << "doc="; (__isset.doc ? (out << to_string(doc)) : (out << "<null>"));
  out << ")";
}


GeneratorInput::~GeneratorInput() throw() {
}


void GeneratorInput::__set_program(const t_program& val) {
  this->program = val;
}

void GeneratorInput::__set_type_registry(const TypeRegistry& val) {
  this->type_registry = val;
}

void GeneratorInput::__set_parsed_options(const std::map<std::string, std::string> & val) {
  this->parsed_options = val;
}

uint32_t GeneratorInput::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_program = false;
  bool isset_type_registry = false;
  bool isset_parsed_options = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->program.read(iprot);
          isset_program = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->type_registry.read(iprot);
          isset_type_registry = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->parsed_options.clear();
            uint32_t _size192;
            ::apache::thrift::protocol::TType _ktype193;
            ::apache::thrift::protocol::TType _vtype194;
            xfer += iprot->readMapBegin(_ktype193, _vtype194, _size192);
            uint32_t _i196;
            for (_i196 = 0; _i196 < _size192; ++_i196)
            {
              std::string _key197;
              xfer += iprot->readString(_key197);
              std::string& _val198 = this->parsed_options[_key197];
              xfer += iprot->readString(_val198);
            }
            xfer += iprot->readMapEnd();
          }
          isset_parsed_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_program)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type_registry)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_parsed_options)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t GeneratorInput::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GeneratorInput");

  xfer += oprot->writeFieldBegin("program", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->program.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type_registry", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->type_registry.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parsed_options", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->parsed_options.size()));
    std::map<std::string, std::string> ::const_iterator _iter199;
    for (_iter199 = this->parsed_options.begin(); _iter199 != this->parsed_options.end(); ++_iter199)
    {
      xfer += oprot->writeString(_iter199->first);
      xfer += oprot->writeString(_iter199->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GeneratorInput &a, GeneratorInput &b) {
  using ::std::swap;
  swap(a.program, b.program);
  swap(a.type_registry, b.type_registry);
  swap(a.parsed_options, b.parsed_options);
}

GeneratorInput::GeneratorInput(const GeneratorInput& other200) {
  program = other200.program;
  type_registry = other200.type_registry;
  parsed_options = other200.parsed_options;
}
GeneratorInput& GeneratorInput::operator=(const GeneratorInput& other201) {
  program = other201.program;
  type_registry = other201.type_registry;
  parsed_options = other201.parsed_options;
  return *this;
}
void GeneratorInput::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GeneratorInput(";
  out << "program=" << to_string(program);
  out << ", " << "type_registry=" << to_string(type_registry);
  out << ", " << "parsed_options=" << to_string(parsed_options);
  out << ")";
}

}}} // namespace
