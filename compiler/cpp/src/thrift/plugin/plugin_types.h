/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef plugin_TYPES_H
#define plugin_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace apache { namespace thrift { namespace plugin {

struct t_base {
  enum type {
    TYPE_VOID = 0,
    TYPE_STRING = 1,
    TYPE_BOOL = 2,
    TYPE_I8 = 3,
    TYPE_I16 = 4,
    TYPE_I32 = 5,
    TYPE_I64 = 6,
    TYPE_DOUBLE = 7,
    TYPE_BINARY = 8
  };
};

extern const std::map<int, const char*> _t_base_VALUES_TO_NAMES;

struct Requiredness {
  enum type {
    T_REQUIRED = 0,
    T_OPTIONAL = 1,
    T_OPT_IN_REQ_OUT = 2
  };
};

extern const std::map<int, const char*> _Requiredness_VALUES_TO_NAMES;

typedef int64_t t_program_id;

typedef int64_t t_type_id;

typedef int64_t t_const_id;

typedef int64_t t_service_id;

class TypeMetadata;

class t_base_type;

class t_list;

class t_set;

class t_map;

class t_typedef;

class t_enum_value;

class t_enum;

class t_const_value;

class t_const;

class t_struct;

class t_field;

class t_function;

class t_service;

class t_type;

class t_scope;

class TypeRegistry;

class t_program;

class GeneratorInput;

typedef struct _TypeMetadata__isset {
  _TypeMetadata__isset() : annotations(false), doc(false) {}
  bool annotations :1;
  bool doc :1;
} _TypeMetadata__isset;

class TypeMetadata : public virtual ::apache::thrift::TBase {
 public:

  TypeMetadata(const TypeMetadata&);
  TypeMetadata& operator=(const TypeMetadata&);
  TypeMetadata() : name(), program_id(0), doc() {
  }

  virtual ~TypeMetadata() throw();
  std::string name;
  t_program_id program_id;
  std::map<std::string, std::string>  annotations;
  std::string doc;

  _TypeMetadata__isset __isset;

  void __set_name(const std::string& val);

  void __set_program_id(const t_program_id val);

  void __set_annotations(const std::map<std::string, std::string> & val);

  void __set_doc(const std::string& val);

  bool operator == (const TypeMetadata & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(program_id == rhs.program_id))
      return false;
    if (__isset.annotations != rhs.__isset.annotations)
      return false;
    else if (__isset.annotations && !(annotations == rhs.annotations))
      return false;
    if (__isset.doc != rhs.__isset.doc)
      return false;
    else if (__isset.doc && !(doc == rhs.doc))
      return false;
    return true;
  }
  bool operator != (const TypeMetadata &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TypeMetadata & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TypeMetadata &a, TypeMetadata &b);

inline std::ostream& operator<<(std::ostream& out, const TypeMetadata& obj)
{
  obj.printTo(out);
  return out;
}


class t_base_type : public virtual ::apache::thrift::TBase {
 public:

  t_base_type(const t_base_type&);
  t_base_type& operator=(const t_base_type&);
  t_base_type() : value((t_base::type)0) {
  }

  virtual ~t_base_type() throw();
  TypeMetadata metadata;
  t_base::type value;

  void __set_metadata(const TypeMetadata& val);

  void __set_value(const t_base::type val);

  bool operator == (const t_base_type & rhs) const
  {
    if (!(metadata == rhs.metadata))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const t_base_type &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const t_base_type & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(t_base_type &a, t_base_type &b);

inline std::ostream& operator<<(std::ostream& out, const t_base_type& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _t_list__isset {
  _t_list__isset() : cpp_name(false) {}
  bool cpp_name :1;
} _t_list__isset;

class t_list : public virtual ::apache::thrift::TBase {
 public:

  t_list(const t_list&);
  t_list& operator=(const t_list&);
  t_list() : cpp_name(), elem_type(0) {
  }

  virtual ~t_list() throw();
  TypeMetadata metadata;
  std::string cpp_name;
  t_type_id elem_type;

  _t_list__isset __isset;

  void __set_metadata(const TypeMetadata& val);

  void __set_cpp_name(const std::string& val);

  void __set_elem_type(const t_type_id val);

  bool operator == (const t_list & rhs) const
  {
    if (!(metadata == rhs.metadata))
      return false;
    if (__isset.cpp_name != rhs.__isset.cpp_name)
      return false;
    else if (__isset.cpp_name && !(cpp_name == rhs.cpp_name))
      return false;
    if (!(elem_type == rhs.elem_type))
      return false;
    return true;
  }
  bool operator != (const t_list &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const t_list & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(t_list &a, t_list &b);

inline std::ostream& operator<<(std::ostream& out, const t_list& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _t_set__isset {
  _t_set__isset() : cpp_name(false) {}
  bool cpp_name :1;
} _t_set__isset;

class t_set : public virtual ::apache::thrift::TBase {
 public:

  t_set(const t_set&);
  t_set& operator=(const t_set&);
  t_set() : cpp_name(), elem_type(0) {
  }

  virtual ~t_set() throw();
  TypeMetadata metadata;
  std::string cpp_name;
  t_type_id elem_type;

  _t_set__isset __isset;

  void __set_metadata(const TypeMetadata& val);

  void __set_cpp_name(const std::string& val);

  void __set_elem_type(const t_type_id val);

  bool operator == (const t_set & rhs) const
  {
    if (!(metadata == rhs.metadata))
      return false;
    if (__isset.cpp_name != rhs.__isset.cpp_name)
      return false;
    else if (__isset.cpp_name && !(cpp_name == rhs.cpp_name))
      return false;
    if (!(elem_type == rhs.elem_type))
      return false;
    return true;
  }
  bool operator != (const t_set &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const t_set & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(t_set &a, t_set &b);

inline std::ostream& operator<<(std::ostream& out, const t_set& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _t_map__isset {
  _t_map__isset() : cpp_name(false) {}
  bool cpp_name :1;
} _t_map__isset;

class t_map : public virtual ::apache::thrift::TBase {
 public:

  t_map(const t_map&);
  t_map& operator=(const t_map&);
  t_map() : cpp_name(), key_type(0), val_type(0) {
  }

  virtual ~t_map() throw();
  TypeMetadata metadata;
  std::string cpp_name;
  t_type_id key_type;
  t_type_id val_type;

  _t_map__isset __isset;

  void __set_metadata(const TypeMetadata& val);

  void __set_cpp_name(const std::string& val);

  void __set_key_type(const t_type_id val);

  void __set_val_type(const t_type_id val);

  bool operator == (const t_map & rhs) const
  {
    if (!(metadata == rhs.metadata))
      return false;
    if (__isset.cpp_name != rhs.__isset.cpp_name)
      return false;
    else if (__isset.cpp_name && !(cpp_name == rhs.cpp_name))
      return false;
    if (!(key_type == rhs.key_type))
      return false;
    if (!(val_type == rhs.val_type))
      return false;
    return true;
  }
  bool operator != (const t_map &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const t_map & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(t_map &a, t_map &b);

inline std::ostream& operator<<(std::ostream& out, const t_map& obj)
{
  obj.printTo(out);
  return out;
}


class t_typedef : public virtual ::apache::thrift::TBase {
 public:

  t_typedef(const t_typedef&);
  t_typedef& operator=(const t_typedef&);
  t_typedef() : type(0), symbolic(), forward(0) {
  }

  virtual ~t_typedef() throw();
  TypeMetadata metadata;
  t_type_id type;
  std::string symbolic;
  bool forward;

  void __set_metadata(const TypeMetadata& val);

  void __set_type(const t_type_id val);

  void __set_symbolic(const std::string& val);

  void __set_forward(const bool val);

  bool operator == (const t_typedef & rhs) const
  {
    if (!(metadata == rhs.metadata))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(symbolic == rhs.symbolic))
      return false;
    if (!(forward == rhs.forward))
      return false;
    return true;
  }
  bool operator != (const t_typedef &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const t_typedef & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(t_typedef &a, t_typedef &b);

inline std::ostream& operator<<(std::ostream& out, const t_typedef& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _t_enum_value__isset {
  _t_enum_value__isset() : annotations(false), doc(false) {}
  bool annotations :1;
  bool doc :1;
} _t_enum_value__isset;

class t_enum_value : public virtual ::apache::thrift::TBase {
 public:

  t_enum_value(const t_enum_value&);
  t_enum_value& operator=(const t_enum_value&);
  t_enum_value() : name(), value(0), doc() {
  }

  virtual ~t_enum_value() throw();
  std::string name;
  int32_t value;
  std::map<std::string, std::string>  annotations;
  std::string doc;

  _t_enum_value__isset __isset;

  void __set_name(const std::string& val);

  void __set_value(const int32_t val);

  void __set_annotations(const std::map<std::string, std::string> & val);

  void __set_doc(const std::string& val);

  bool operator == (const t_enum_value & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(value == rhs.value))
      return false;
    if (__isset.annotations != rhs.__isset.annotations)
      return false;
    else if (__isset.annotations && !(annotations == rhs.annotations))
      return false;
    if (__isset.doc != rhs.__isset.doc)
      return false;
    else if (__isset.doc && !(doc == rhs.doc))
      return false;
    return true;
  }
  bool operator != (const t_enum_value &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const t_enum_value & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(t_enum_value &a, t_enum_value &b);

inline std::ostream& operator<<(std::ostream& out, const t_enum_value& obj)
{
  obj.printTo(out);
  return out;
}


class t_enum : public virtual ::apache::thrift::TBase {
 public:

  t_enum(const t_enum&);
  t_enum& operator=(const t_enum&);
  t_enum() {
  }

  virtual ~t_enum() throw();
  TypeMetadata metadata;
  std::vector<t_enum_value>  constants;

  void __set_metadata(const TypeMetadata& val);

  void __set_constants(const std::vector<t_enum_value> & val);

  bool operator == (const t_enum & rhs) const
  {
    if (!(metadata == rhs.metadata))
      return false;
    if (!(constants == rhs.constants))
      return false;
    return true;
  }
  bool operator != (const t_enum &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const t_enum & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(t_enum &a, t_enum &b);

inline std::ostream& operator<<(std::ostream& out, const t_enum& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _t_const_value__isset {
  _t_const_value__isset() : map_val(false), list_val(false), string_val(false), integer_val(false), double_val(false), identifier_val(false), enum_val(false) {}
  bool map_val :1;
  bool list_val :1;
  bool string_val :1;
  bool integer_val :1;
  bool double_val :1;
  bool identifier_val :1;
  bool enum_val :1;
} _t_const_value__isset;

class t_const_value : public virtual ::apache::thrift::TBase {
 public:

  t_const_value(const t_const_value&);
  t_const_value& operator=(const t_const_value&);
  t_const_value() : string_val(), integer_val(0), double_val(0), identifier_val(), enum_val(0) {
  }

  virtual ~t_const_value() throw();
  std::map<t_const_value, t_const_value>  map_val;
  std::vector<t_const_value>  list_val;
  std::string string_val;
  int64_t integer_val;
  double double_val;
  std::string identifier_val;
  t_type_id enum_val;

  _t_const_value__isset __isset;

  void __set_map_val(const std::map<t_const_value, t_const_value> & val);

  void __set_list_val(const std::vector<t_const_value> & val);

  void __set_string_val(const std::string& val);

  void __set_integer_val(const int64_t val);

  void __set_double_val(const double val);

  void __set_identifier_val(const std::string& val);

  void __set_enum_val(const t_type_id val);

  bool operator == (const t_const_value & rhs) const
  {
    if (__isset.map_val != rhs.__isset.map_val)
      return false;
    else if (__isset.map_val && !(map_val == rhs.map_val))
      return false;
    if (__isset.list_val != rhs.__isset.list_val)
      return false;
    else if (__isset.list_val && !(list_val == rhs.list_val))
      return false;
    if (__isset.string_val != rhs.__isset.string_val)
      return false;
    else if (__isset.string_val && !(string_val == rhs.string_val))
      return false;
    if (__isset.integer_val != rhs.__isset.integer_val)
      return false;
    else if (__isset.integer_val && !(integer_val == rhs.integer_val))
      return false;
    if (__isset.double_val != rhs.__isset.double_val)
      return false;
    else if (__isset.double_val && !(double_val == rhs.double_val))
      return false;
    if (__isset.identifier_val != rhs.__isset.identifier_val)
      return false;
    else if (__isset.identifier_val && !(identifier_val == rhs.identifier_val))
      return false;
    if (__isset.enum_val != rhs.__isset.enum_val)
      return false;
    else if (__isset.enum_val && !(enum_val == rhs.enum_val))
      return false;
    return true;
  }
  bool operator != (const t_const_value &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const t_const_value & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(t_const_value &a, t_const_value &b);

inline std::ostream& operator<<(std::ostream& out, const t_const_value& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _t_const__isset {
  _t_const__isset() : doc(false) {}
  bool doc :1;
} _t_const__isset;

class t_const : public virtual ::apache::thrift::TBase {
 public:

  t_const(const t_const&);
  t_const& operator=(const t_const&);
  t_const() : name(), type(0), doc() {
  }

  virtual ~t_const() throw();
  std::string name;
  t_type_id type;
  t_const_value value;
  std::string doc;

  _t_const__isset __isset;

  void __set_name(const std::string& val);

  void __set_type(const t_type_id val);

  void __set_value(const t_const_value& val);

  void __set_doc(const std::string& val);

  bool operator == (const t_const & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(value == rhs.value))
      return false;
    if (__isset.doc != rhs.__isset.doc)
      return false;
    else if (__isset.doc && !(doc == rhs.doc))
      return false;
    return true;
  }
  bool operator != (const t_const &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const t_const & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(t_const &a, t_const &b);

inline std::ostream& operator<<(std::ostream& out, const t_const& obj)
{
  obj.printTo(out);
  return out;
}


class t_struct : public virtual ::apache::thrift::TBase {
 public:

  t_struct(const t_struct&);
  t_struct& operator=(const t_struct&);
  t_struct() : is_union(0), is_xception(0) {
  }

  virtual ~t_struct() throw();
  TypeMetadata metadata;
  std::vector<t_field>  members;
  bool is_union;
  bool is_xception;

  void __set_metadata(const TypeMetadata& val);

  void __set_members(const std::vector<t_field> & val);

  void __set_is_union(const bool val);

  void __set_is_xception(const bool val);

  bool operator == (const t_struct & rhs) const
  {
    if (!(metadata == rhs.metadata))
      return false;
    if (!(members == rhs.members))
      return false;
    if (!(is_union == rhs.is_union))
      return false;
    if (!(is_xception == rhs.is_xception))
      return false;
    return true;
  }
  bool operator != (const t_struct &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const t_struct & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(t_struct &a, t_struct &b);

inline std::ostream& operator<<(std::ostream& out, const t_struct& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _t_field__isset {
  _t_field__isset() : value(false), annotations(false), doc(false) {}
  bool value :1;
  bool annotations :1;
  bool doc :1;
} _t_field__isset;

class t_field : public virtual ::apache::thrift::TBase {
 public:

  t_field(const t_field&);
  t_field& operator=(const t_field&);
  t_field() : name(), type(0), key(0), req((Requiredness::type)0), reference(0), doc() {
  }

  virtual ~t_field() throw();
  std::string name;
  t_type_id type;
  int32_t key;
  Requiredness::type req;
  t_const_value value;
  bool reference;
  std::map<std::string, std::string>  annotations;
  std::string doc;

  _t_field__isset __isset;

  void __set_name(const std::string& val);

  void __set_type(const t_type_id val);

  void __set_key(const int32_t val);

  void __set_req(const Requiredness::type val);

  void __set_value(const t_const_value& val);

  void __set_reference(const bool val);

  void __set_annotations(const std::map<std::string, std::string> & val);

  void __set_doc(const std::string& val);

  bool operator == (const t_field & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(key == rhs.key))
      return false;
    if (!(req == rhs.req))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (!(reference == rhs.reference))
      return false;
    if (__isset.annotations != rhs.__isset.annotations)
      return false;
    else if (__isset.annotations && !(annotations == rhs.annotations))
      return false;
    if (__isset.doc != rhs.__isset.doc)
      return false;
    else if (__isset.doc && !(doc == rhs.doc))
      return false;
    return true;
  }
  bool operator != (const t_field &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const t_field & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(t_field &a, t_field &b);

inline std::ostream& operator<<(std::ostream& out, const t_field& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _t_function__isset {
  _t_function__isset() : doc(false) {}
  bool doc :1;
} _t_function__isset;

class t_function : public virtual ::apache::thrift::TBase {
 public:

  t_function(const t_function&);
  t_function& operator=(const t_function&);
  t_function() : name(), returntype(0), arglist(0), xceptions(0), is_oneway(0), doc() {
  }

  virtual ~t_function() throw();
  std::string name;
  t_type_id returntype;
  t_type_id arglist;
  t_type_id xceptions;
  bool is_oneway;
  std::string doc;

  _t_function__isset __isset;

  void __set_name(const std::string& val);

  void __set_returntype(const t_type_id val);

  void __set_arglist(const t_type_id val);

  void __set_xceptions(const t_type_id val);

  void __set_is_oneway(const bool val);

  void __set_doc(const std::string& val);

  bool operator == (const t_function & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(returntype == rhs.returntype))
      return false;
    if (!(arglist == rhs.arglist))
      return false;
    if (!(xceptions == rhs.xceptions))
      return false;
    if (!(is_oneway == rhs.is_oneway))
      return false;
    if (__isset.doc != rhs.__isset.doc)
      return false;
    else if (__isset.doc && !(doc == rhs.doc))
      return false;
    return true;
  }
  bool operator != (const t_function &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const t_function & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(t_function &a, t_function &b);

inline std::ostream& operator<<(std::ostream& out, const t_function& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _t_service__isset {
  _t_service__isset() : extends_(false) {}
  bool extends_ :1;
} _t_service__isset;

class t_service : public virtual ::apache::thrift::TBase {
 public:

  t_service(const t_service&);
  t_service& operator=(const t_service&);
  t_service() : extends_(0) {
  }

  virtual ~t_service() throw();
  TypeMetadata metadata;
  std::vector<t_function>  functions;
  t_service_id extends_;

  _t_service__isset __isset;

  void __set_metadata(const TypeMetadata& val);

  void __set_functions(const std::vector<t_function> & val);

  void __set_extends_(const t_service_id val);

  bool operator == (const t_service & rhs) const
  {
    if (!(metadata == rhs.metadata))
      return false;
    if (!(functions == rhs.functions))
      return false;
    if (__isset.extends_ != rhs.__isset.extends_)
      return false;
    else if (__isset.extends_ && !(extends_ == rhs.extends_))
      return false;
    return true;
  }
  bool operator != (const t_service &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const t_service & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(t_service &a, t_service &b);

inline std::ostream& operator<<(std::ostream& out, const t_service& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _t_type__isset {
  _t_type__isset() : base_type_val(false), typedef_val(false), enum_val(false), struct_val(false), xception_val(false), list_val(false), set_val(false), map_val(false), service_val(false) {}
  bool base_type_val :1;
  bool typedef_val :1;
  bool enum_val :1;
  bool struct_val :1;
  bool xception_val :1;
  bool list_val :1;
  bool set_val :1;
  bool map_val :1;
  bool service_val :1;
} _t_type__isset;

class t_type : public virtual ::apache::thrift::TBase {
 public:

  t_type(const t_type&);
  t_type& operator=(const t_type&);
  t_type() {
  }

  virtual ~t_type() throw();
  t_base_type base_type_val;
  t_typedef typedef_val;
  t_enum enum_val;
  t_struct struct_val;
  t_struct xception_val;
  t_list list_val;
  t_set set_val;
  t_map map_val;
  t_service service_val;

  _t_type__isset __isset;

  void __set_base_type_val(const t_base_type& val);

  void __set_typedef_val(const t_typedef& val);

  void __set_enum_val(const t_enum& val);

  void __set_struct_val(const t_struct& val);

  void __set_xception_val(const t_struct& val);

  void __set_list_val(const t_list& val);

  void __set_set_val(const t_set& val);

  void __set_map_val(const t_map& val);

  void __set_service_val(const t_service& val);

  bool operator == (const t_type & rhs) const
  {
    if (__isset.base_type_val != rhs.__isset.base_type_val)
      return false;
    else if (__isset.base_type_val && !(base_type_val == rhs.base_type_val))
      return false;
    if (__isset.typedef_val != rhs.__isset.typedef_val)
      return false;
    else if (__isset.typedef_val && !(typedef_val == rhs.typedef_val))
      return false;
    if (__isset.enum_val != rhs.__isset.enum_val)
      return false;
    else if (__isset.enum_val && !(enum_val == rhs.enum_val))
      return false;
    if (__isset.struct_val != rhs.__isset.struct_val)
      return false;
    else if (__isset.struct_val && !(struct_val == rhs.struct_val))
      return false;
    if (__isset.xception_val != rhs.__isset.xception_val)
      return false;
    else if (__isset.xception_val && !(xception_val == rhs.xception_val))
      return false;
    if (__isset.list_val != rhs.__isset.list_val)
      return false;
    else if (__isset.list_val && !(list_val == rhs.list_val))
      return false;
    if (__isset.set_val != rhs.__isset.set_val)
      return false;
    else if (__isset.set_val && !(set_val == rhs.set_val))
      return false;
    if (__isset.map_val != rhs.__isset.map_val)
      return false;
    else if (__isset.map_val && !(map_val == rhs.map_val))
      return false;
    if (__isset.service_val != rhs.__isset.service_val)
      return false;
    else if (__isset.service_val && !(service_val == rhs.service_val))
      return false;
    return true;
  }
  bool operator != (const t_type &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const t_type & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(t_type &a, t_type &b);

inline std::ostream& operator<<(std::ostream& out, const t_type& obj)
{
  obj.printTo(out);
  return out;
}


class t_scope : public virtual ::apache::thrift::TBase {
 public:

  t_scope(const t_scope&);
  t_scope& operator=(const t_scope&);
  t_scope() {
  }

  virtual ~t_scope() throw();
  std::vector<t_type_id>  types;
  std::vector<t_const_id>  constants;
  std::vector<t_service_id>  services;

  void __set_types(const std::vector<t_type_id> & val);

  void __set_constants(const std::vector<t_const_id> & val);

  void __set_services(const std::vector<t_service_id> & val);

  bool operator == (const t_scope & rhs) const
  {
    if (!(types == rhs.types))
      return false;
    if (!(constants == rhs.constants))
      return false;
    if (!(services == rhs.services))
      return false;
    return true;
  }
  bool operator != (const t_scope &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const t_scope & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(t_scope &a, t_scope &b);

inline std::ostream& operator<<(std::ostream& out, const t_scope& obj)
{
  obj.printTo(out);
  return out;
}


class TypeRegistry : public virtual ::apache::thrift::TBase {
 public:

  TypeRegistry(const TypeRegistry&);
  TypeRegistry& operator=(const TypeRegistry&);
  TypeRegistry() {
  }

  virtual ~TypeRegistry() throw();
  std::map<t_type_id, t_type>  types;
  std::map<t_const_id, t_const>  constants;
  std::map<t_service_id, t_service>  services;

  void __set_types(const std::map<t_type_id, t_type> & val);

  void __set_constants(const std::map<t_const_id, t_const> & val);

  void __set_services(const std::map<t_service_id, t_service> & val);

  bool operator == (const TypeRegistry & rhs) const
  {
    if (!(types == rhs.types))
      return false;
    if (!(constants == rhs.constants))
      return false;
    if (!(services == rhs.services))
      return false;
    return true;
  }
  bool operator != (const TypeRegistry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TypeRegistry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TypeRegistry &a, TypeRegistry &b);

inline std::ostream& operator<<(std::ostream& out, const TypeRegistry& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _t_program__isset {
  _t_program__isset() : doc(false) {}
  bool doc :1;
} _t_program__isset;

class t_program : public virtual ::apache::thrift::TBase {
 public:

  t_program(const t_program&);
  t_program& operator=(const t_program&);
  t_program() : name(), program_id(0), path(), namespace_(), out_path(), out_path_is_absolute(0), include_prefix(), doc() {
  }

  virtual ~t_program() throw();
  std::string name;
  t_program_id program_id;
  std::string path;
  std::string namespace_;
  std::string out_path;
  bool out_path_is_absolute;
  std::vector<t_program>  includes;
  std::string include_prefix;
  t_scope scope;
  std::vector<t_type_id>  typedefs;
  std::vector<t_type_id>  enums;
  std::vector<t_const_id>  consts;
  std::vector<t_type_id>  objects;
  std::vector<t_service_id>  services;
  std::map<std::string, std::string>  namespaces;
  std::vector<std::string>  cpp_includes;
  std::vector<std::string>  c_includes;
  std::string doc;

  _t_program__isset __isset;

  void __set_name(const std::string& val);

  void __set_program_id(const t_program_id val);

  void __set_path(const std::string& val);

  void __set_namespace_(const std::string& val);

  void __set_out_path(const std::string& val);

  void __set_out_path_is_absolute(const bool val);

  void __set_includes(const std::vector<t_program> & val);

  void __set_include_prefix(const std::string& val);

  void __set_scope(const t_scope& val);

  void __set_typedefs(const std::vector<t_type_id> & val);

  void __set_enums(const std::vector<t_type_id> & val);

  void __set_consts(const std::vector<t_const_id> & val);

  void __set_objects(const std::vector<t_type_id> & val);

  void __set_services(const std::vector<t_service_id> & val);

  void __set_namespaces(const std::map<std::string, std::string> & val);

  void __set_cpp_includes(const std::vector<std::string> & val);

  void __set_c_includes(const std::vector<std::string> & val);

  void __set_doc(const std::string& val);

  bool operator == (const t_program & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(program_id == rhs.program_id))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(namespace_ == rhs.namespace_))
      return false;
    if (!(out_path == rhs.out_path))
      return false;
    if (!(out_path_is_absolute == rhs.out_path_is_absolute))
      return false;
    if (!(includes == rhs.includes))
      return false;
    if (!(include_prefix == rhs.include_prefix))
      return false;
    if (!(scope == rhs.scope))
      return false;
    if (!(typedefs == rhs.typedefs))
      return false;
    if (!(enums == rhs.enums))
      return false;
    if (!(consts == rhs.consts))
      return false;
    if (!(objects == rhs.objects))
      return false;
    if (!(services == rhs.services))
      return false;
    if (!(namespaces == rhs.namespaces))
      return false;
    if (!(cpp_includes == rhs.cpp_includes))
      return false;
    if (!(c_includes == rhs.c_includes))
      return false;
    if (__isset.doc != rhs.__isset.doc)
      return false;
    else if (__isset.doc && !(doc == rhs.doc))
      return false;
    return true;
  }
  bool operator != (const t_program &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const t_program & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(t_program &a, t_program &b);

inline std::ostream& operator<<(std::ostream& out, const t_program& obj)
{
  obj.printTo(out);
  return out;
}


class GeneratorInput : public virtual ::apache::thrift::TBase {
 public:

  GeneratorInput(const GeneratorInput&);
  GeneratorInput& operator=(const GeneratorInput&);
  GeneratorInput() {
  }

  virtual ~GeneratorInput() throw();
  t_program program;
  TypeRegistry type_registry;
  std::map<std::string, std::string>  parsed_options;

  void __set_program(const t_program& val);

  void __set_type_registry(const TypeRegistry& val);

  void __set_parsed_options(const std::map<std::string, std::string> & val);

  bool operator == (const GeneratorInput & rhs) const
  {
    if (!(program == rhs.program))
      return false;
    if (!(type_registry == rhs.type_registry))
      return false;
    if (!(parsed_options == rhs.parsed_options))
      return false;
    return true;
  }
  bool operator != (const GeneratorInput &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GeneratorInput & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GeneratorInput &a, GeneratorInput &b);

inline std::ostream& operator<<(std::ostream& out, const GeneratorInput& obj)
{
  obj.printTo(out);
  return out;
}

}}} // namespace

#endif
